# -*- coding: utf-8 -*-
"""ResNet-18.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-xTI8u8g30hAUn452XeUcM7iZQFtCwCb
"""

# ResNet18 on BreastMNIST: https://medmnist.com/

# --- 1. Install and Import ---
# We run the installation quietly with `-q`
!pip install -q medmnist

import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader
import torchvision.transforms as transforms
from torchvision.models import resnet18
import medmnist
from medmnist import INFO, Evaluator
from tqdm import tqdm

print(f"Successfully imported libraries. Using MedMNIST version: {medmnist.__version__}")

# --- 2. Setup Dataset and Dataloaders ---
# This is the most critical part for fixing the error.
# We ensure the variable is set correctly before it's used.
data_flag = 'breastmnist'
print(f"INFO: The data_flag is set to: '{data_flag}'") # Debug print

BATCH_SIZE = 128
download = True

# Get dataset information from the medmnist library
info = INFO[data_flag]

# CORRECTED LINE: The key is 'n_channels' with an 's'
n_channels = info['n_channels']
n_classes = len(info['label'])
DataClass = getattr(medmnist, info['python_class'])

# Define transformations to apply to the images
data_transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize(mean=[.5], std=[.5])
])

# Load the datasets using the predefined splits and apply the transformations
train_dataset = DataClass(split='train', transform=data_transform, download=download)
val_dataset = DataClass(split='val', transform=data_transform, download=download)
test_dataset = DataClass(split='test', transform=data_transform, download=download)

# Create DataLoaders to handle batching and shuffling
train_loader = DataLoader(dataset=train_dataset, batch_size=BATCH_SIZE, shuffle=True)
val_loader = DataLoader(dataset=val_dataset, batch_size=BATCH_SIZE, shuffle=False)
test_loader = DataLoader(dataset=test_dataset, batch_size=BATCH_SIZE, shuffle=False)

print("INFO: Datasets and Dataloaders are ready.")

# --- 3. Define and Prepare the Model ---
# Use ResNet-18 and train from scratch (pretrained=False)
model = resnet18(pretrained=False)

# Adjust the model for our specific dataset (1-channel grayscale images)
model.conv1 = nn.Conv2d(n_channels, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)
# Adjust the final layer for our number of classes (2 for BreastMNIST)
model.fc = nn.Linear(model.fc.in_features, n_classes)

# Move the model to the GPU if one is available
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
model.to(device)

print(f"INFO: ResNet-18 model is defined and moved to device: {device}")

# --- 4. Define Loss, Optimizer, and Training Parameters ---
NUM_EPOCHS = 100 # Set to a low number for a quick test. Increase to 100 for full replication.
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(model.parameters(), lr=0.001, momentum=0.9)

print(f"INFO: Starting training for {NUM_EPOCHS} epochs...")

# --- 5. Training and Validation Loop ---
for epoch in range(NUM_EPOCHS):
    # Training phase
    model.train()
    for inputs, targets in tqdm(train_loader, desc=f"Epoch {epoch + 1}/{NUM_EPOCHS} [Train]"):
        inputs, targets = inputs.to(device), targets.to(device).squeeze().long()
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, targets)
        loss.backward()
        optimizer.step()

    # Validation phase
    model.eval()
    y_true_val, y_score_val = [], []
    with torch.no_grad():
        for inputs, targets in val_loader:
            inputs = inputs.to(device)
            outputs = model(inputs)
            y_true_val.extend(targets.squeeze().tolist())
            y_score_val.extend(outputs.softmax(dim=-1).cpu().numpy())

    # convert the list of arrays into a single NumPy array
    y_score_val = np.vstack(y_score_val)

    # Calculate validation metrics
    val_evaluator = Evaluator(data_flag, 'val')
    metrics = val_evaluator.evaluate(y_score_val)
    print(f"Epoch {epoch + 1}/{NUM_EPOCHS} - Validation AUC: {metrics[0]:.3f}, Accuracy: {metrics[1]:.3f}")

print("\nINFO: Training complete!")

# --- 6. Final Evaluation on Test Set ---
print("INFO: Evaluating model on the final test set...")
model.eval()
y_true_test, y_score_test = [], []
with torch.no_grad():
    for inputs, targets in tqdm(test_loader, desc="[Test]"):
        inputs = inputs.to(device)
        outputs = model(inputs)
        y_true_test.extend(targets.squeeze().tolist())
        y_score_test.extend(outputs.softmax(dim=-1).cpu().numpy())

y_score_test = np.vstack(y_score_test)

# Calculate final test metrics
test_evaluator = Evaluator(data_flag, 'test')
test_auc, test_acc = test_evaluator.evaluate(y_score_test)

print("-" * 30)
print(f"Final Test Results for ResNet-18:")
print(f"Test AUC: {test_auc:.3f}")
print(f"Test Accuracy: {test_acc:.3f}")
print("-" * 30)
